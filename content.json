{"pages":[],"posts":[{"title":"","text":"title: jstat工具date: 2019-10-10 15:48:18tags: JVMcategories: Java jstat工具的主要选项 选项 作用 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -gc 监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到最大、最小空间 -gcutil 监视内容基本与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 -gcold 监视老年代GC状况 -gcoldcapacity 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译器编译过的方法、耗时等信息 -printcompilation 输出已经被JIT编译的方法 -gcmetacapacity 输出元数据空间使用信息 -class Loaded Bytes Unloaded Bytes Time 装载的类的数量 装载类所占用的字节数 卸载类的数量 卸载类的字节数 装载和卸载类所花费的时间 -gc S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT CGC CGCT GCT 年轻代中第一个survivor的容量 年轻代中第二个survivor的容量 年轻代中第一个survivor目前已使用的空间 年轻代中第二个survivor目前已使用的空间 年轻代中Eden的容量 年轻代中Eden目前已使用空间 Old代的容量 Old代目前已使用的空间 元空间的容量 元空间目前已使用空间 压缩类空间大小 压缩类空间使用大小 年轻代gc次数 年轻代gc时间 old代gc次数 old代gc所用时间 并行GC收集次数 并行GC收集所用时间 gc总时间 -gccapacity NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC CGC 新生代最小容量 新生代最大容量 当前新生代容量 第一个survivor大小 第二个survivor大小 Eden区大小 老年代最小容量 老年代最大容量 Old代当前新生成的容量 Old代的容量 最小元数据容量 最大元数据容量 当前元数据空间 压缩类空间最小值 压缩类空间最大值 压缩类空间大小 年轻代GC次数 FULL GC的次数 并行GC次数 -gcutil S0 S1 E O M CCS YGC YGCT FGC FGCT CGC CGCT GCT surivor1已使用容量百分比 survivor2以使用容量百分比 Eden使用容量百分比 Old代已使用容量百分比 元数据空间已使用容量百分比 压缩使用比例 年轻代GC次数 年轻代GC时间 FULLGC次数 FULLGC时间 并行GC次数 并行GC时间 GC时间 -gcnew S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT surivor0的容量 survior1的容量 survior0的利用率 survior1的利用率 持有次数限制 最大持有次数 期望survior大小 Eden大小 Eden利用率 年轻代GC次数 年轻代GC时间 -gcnewcapacity NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC CGC 最小新生代大小 最大新生代大小 新生代大小 最大survior0容量大小 survior0大小 最大survior1容量大小 survior1大小 最大Eden区容量 Eden容量 年轻代GC次数 Full GC 次数 并发GC次数 -gcold MC MU CCSC CCSU OC OU YGC FGC FGCT CGC CGCT GCT 当前元数据空间大小 元数据空间利用率 压缩类空间大小 压缩类空间利用率 老年代大小 老年代利用率 年轻代GC次数 FULL GC次数 FULL GC时间 并行收集次数 并行收集时间 GC时间 -gcoldcapacity OGCMN OGCMX OGC OC YGC FGC FGCT CGC CGCT GCT -gcpermcapacity Java11中不存在 替换它的是gcmetacapacity -gcmetacapacity MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC FGCT CGC CGCT GCT 元数据空间最小值 元数据空间最大值 元数据空间大小 压缩的类空间最小值 压缩类空间的最大值 年轻代GC次数 FULL GC次数 并行GC次数 并行GC时间 GC总时间 -compiler Compiled Failed Invalid Time FailedType FailedMethod 被执行的编译任务数量 失败的编译任务数量 无效的编译任务数量 编译任务用的时间 最近编译失败的编译类型 最近编译失败的类名和方法名 -printcompilation Compiled Size Type Method 有最近编译方法执行的编译任务数量 最近编译方法的字节码的字节数 最近编译方法的编译类型 最近编译识别的类名 和 方法名","link":"/jstat/"},{"title":"面试历险记-乐信","text":"今天去乐信参加了一场面试，问了一些问题，结果感觉自己的基础好差劲，有些东西长时间不碰也忘记了。伤心了，写下了供以后参考参考。 索引like会不会用到索引？ %张三、张三%、%张三%哪些用到了索引 参照索引最左原则， %张三是会使用到索引的， 但是张三%、%张三%不会用到 已知字段a和字段b都有独立索引， 那么 where a = 1 order by b会用到哪个索引 当语句是 where a = 1 order by b时 只会用到a字段索引 而 b字段索引不会用到当语句是order by b时，会用到b字段索引因为一条语句只会使用到一个索引， 而 where 和 order by 都会用到索引， 至于用到a的原因是 SQL的执行顺序。 zk的选举机制 不甚清楚，还待学习 zk的leader、follower、monitor的区别？ monitor的功能与leader 和 follower基本一致，只是 monitor不能参加选举， 更详细的，待查 JVM运行的数据区域都存的什么东西？ 堆（Heap）：线程共享的，主要保存对象实例，它是GC的主要区域。当堆中没有足够的空间分配实例时会报OutOfMemoryError 虚拟机栈（Stack）: 线程私有的，生命周期与线程一致，描述的是JAVA方法的内存模型，执行方法时会创建一个栈帧，存储局部变量表操作数栈、动态链接、方法出口等信息； 局部变量表存放了编译期可知的基本类型和对象引用。线程请求深度超过栈规定时报StackOverflowError、动态扩展时如果无法申请到足够内存会报OutOfMemoryError 方法区（Method Area）: 线程共享的，用于存储类信息、常量、静态变量、即时编译器编译后的代码。会有GC,主要目标是常量池的回收和类型的卸载， 当无法满足分配需求是报OutOfMemoryError之所以不列出 程序计数器和本地方法栈的原因在于， 程序计数器在某些虚拟机中并不存在，本地方法栈在某些虚拟机中与方法区合并了 RPC与HTTP的区别？ RPC: 远程过程调用的协议； HTTP：超文本协议RPC可以使用HTTP协议实现这只是一部分，后面会单独写一篇出来 Kafka与RabbitMQ的技术选型 面试时主要是考察的广播性RabbitMQ的广播要比Kafka的要差 公司的业务量、分库分表方案？ 面试官提供的建议是，在分表的时候关联信息的后缀5位或者更多，后缀使用数字，那么在分表的时候，可以参考后五位数字进行参考分表。","link":"/interview-LX/"},{"title":"初识RabbitMQ（一）","text":"之前一直听别人说Rabbit、Kafka、Rocket这几类的MQ, 加之前段时间在项目中用到了RabbitMQ, 用的过程中对其中的概念并不是很清楚，所以想去了解学习一下。 AMQP协议 RabbitMQ是遵从AMQP协议的","link":"/acquaint-rabbitMQ/"},{"title":"少年中国说","text":"日本人之称我中国也，一则曰老大帝国，再则曰老大帝国。是语也，盖袭译欧西人之言也。呜呼！我中国其果老大矣乎？梁启超曰：恶！是何言！是何言！吾心目中有一少年中国在！ 欲言国之老少，请先言人之老少。老年人常思既往，少年人常思将来。惟思既往也，故生留恋心；惟思将来也，故生希望心。惟留恋也，故保守；惟希望也，故进取。惟保守也，故永旧；惟进取也，故日新。惟思既往也，事事皆其所已经者，故惟知照例；惟思将来也，事事皆其所未经者，故常敢破格。老年人常多忧虑，少年人常好行乐。惟多忧也，故灰心；惟行乐也，故盛气。惟灰心也，故怯懦；惟盛气也，故豪壮。惟怯懦也，故苟且；惟豪壮也，故冒险。惟苟且也，故能灭世界；惟冒险也，故能造世界。老年人常厌事，少年人常喜事。惟厌事也，故常觉一切事无可为者；惟好事也，故常觉一切事无不可为者。老年人如夕照，少年人如朝阳；老年人如瘠牛，少年人如乳虎。老年人如僧，少年人如侠。老年人如字典，少年人如戏文。老年人如鸦片烟，少年人如泼兰地酒。老年人如别行星之陨石，少年人如大洋海之珊瑚岛。老年人如埃及沙漠之金字塔，少年人如西比利亚之铁路；老年人如秋后之柳，少年人如春前之草。老年人如死海之潴为泽，少年人如长江之初发源。此老年与少年性格不同之大略也。任公曰：人固有之，国亦宜然。 梁启超曰：伤哉，老大也！浔阳江头琵琶妇，当明月绕船，枫叶瑟瑟，衾寒于铁，似梦非梦之时，追想洛阳尘中春花秋月之佳趣。西宫南内，白发宫娥，一灯如穗，三五对坐，谈开元、天宝间遗事，谱《霓裳羽衣曲》。青门种瓜人，左对孺人，顾弄孺子，忆侯门似海珠履杂遝之盛事。拿破仑之流于厄蔑，阿剌飞之幽于锡兰，与三两监守吏，或过访之好事者，道当年短刀匹马驰骋中原，席卷欧洲，血战海楼，一声叱咤，万国震恐之丰功伟烈，初而拍案，继而抚髀，终而揽镜。呜呼，面皴齿尽，白发盈把，颓然老矣！若是者，舍幽郁之外无心事，舍悲惨之外无天地，舍颓唐之外无日月，舍叹息之外无音声，舍待死之外无事业。美人豪杰且然，而况寻常碌碌者耶？生平亲友，皆在墟墓；起居饮食，待命于人。今日且过，遑知他日？今年且过，遑恤明年？普天下灰心短气之事，未有甚于老大者。于此人也，而欲望以拏云之手段，回天之事功，挟山超海之意气，能乎不能？ 呜呼！我中国其果老大矣乎？立乎今日以指畴昔，唐虞三代，若何之郅治；秦皇汉武，若何之雄杰；汉唐来之文学，若何之隆盛；康乾间之武功，若何之烜赫。历史家所铺叙，词章家所讴歌，何一非我国民少年时代良辰美景、赏心乐事之陈迹哉！而今颓然老矣！昨日割五城，明日割十城，处处雀鼠尽，夜夜鸡犬惊。十八省之土地财产，已为人怀中之肉；四百兆之父兄子弟，已为人注籍之奴，岂所谓“老大嫁作商人妇”者耶？呜呼！凭君莫话当年事，憔悴韶光不忍看！楚囚相对，岌岌顾影，人命危浅，朝不虑夕。国为待死之国，一国之民为待死之民。万事付之奈何，一切凭人作弄，亦何足怪！ 任公曰：我中国其果老大矣乎？是今日全地球之一大问题也。如其老大也，则是中国为过去之国，即地球上昔本有此国，而今渐澌灭，他日之命运殆将尽也。如其非老大也，则是中国为未来之国，即地球上昔未现此国，而今渐发达，他日之前程且方长也。欲断今日之中国为老大耶？为少年耶？则不可不先明“国”字之意义。夫国也者，何物也？有土地，有人民，以居于其土地之人民，而治其所居之土地之事，自制法律而自守之；有主权，有服从，人人皆主权者，人人皆服从者。夫如是，斯谓之完全成立之国，地球上之有完全成立之国也，自百年以来也。完全成立者，壮年之事也。未能完全成立而渐进于完全成立者，少年之事也。故吾得一言以断之曰：欧洲列邦在今日为壮年国，而我中国在今日为少年国。 夫古昔之中国者，虽有国之名，而未成国之形也。或为家族之国，或为酋长之国，或为诸侯封建之国，或为一王专制之国。虽种类不一，要之，其于国家之体质也，有其一部而缺其一部。正如婴儿自胚胎以迄成童，其身体之一二官支，先行长成，此外则全体虽粗具，然未能得其用也。故唐虞以前为胚胎时代，殷周之际为乳哺时代，由孔子而来至于今为童子时代。逐渐发达，而今乃始将入成童以上少年之界焉。其长成所以若是之迟者，则历代之民贼有窒其生机者也。譬犹童年多病，转类老态，或且疑其死期之将至焉，而不知皆由未完成未成立也。非过去之谓，而未来之谓也。 且我中国畴昔，岂尝有国家哉？不过有朝廷耳！我黄帝子孙，聚族而居，立于此地球之上者既数千年，而问其国之为何名，则无有也。夫所谓唐、虞、夏、商、周、秦、汉、魏、晋、宋、齐、梁、陈、隋、唐、宋、元、明、清者，则皆朝名耳。朝也者，一家之私产也。国也者，人民之公产也。朝有朝之老少，国有国之老少。朝与国既异物，则不能以朝之老少而指为国之老少明矣。文、武、成、康，周朝之少年时代也。幽、厉、桓、赧，则其老年时代也。高、文、景、武，汉朝之少年时代也。元、平、桓、灵，则其老年时代也。自余历朝，莫不有之。凡此者谓为一朝廷之老也则可，谓为一国之老也则不可。一朝廷之老旦死，犹一人之老且死也，于吾所谓中国者何与焉。然则，吾中国者，前此尚未出现于世界，而今乃始萌芽云尔。天地大矣，前途辽矣。美哉我少年中国乎！ 玛志尼者，意大利三杰之魁也。以国事被罪，逃窜异邦。乃创立一会，名曰“少年意大利”。举国志士，云涌雾集以应之。卒乃光复旧物，使意大利为欧洲之一雄邦。夫意大利者，欧洲之第一老大国也。自罗马亡后，土地隶于教皇，政权归于奥国，殆所谓老而濒于死者矣。而得一玛志尼，且能举全国而少年之，况我中国之实为少年时代者耶！堂堂四百余州之国土，凛凛四百余兆之国民，岂遂无一玛志尼其人者！ 龚自珍氏之集有诗一章，题曰《能令公少年行》。吾尝爱读之，而有味乎其用意之所存。我国民而自谓其国之老大也，斯果老大矣；我国民而自知其国之少年也，斯乃少年矣。西谚有之曰：“有三岁之翁，有百岁之童。”然则，国之老少，又无定形，而实随国民之心力以为消长者也。吾见乎玛志尼之能令国少年也，吾又见乎我国之官吏士民能令国老大也。吾为此惧！夫以如此壮丽浓郁翩翩绝世之少年中国，而使欧西日本人谓我为老大者，何也？则以握国权者皆老朽之人也。非哦几十年八股，非写几十年白折，非当几十年差，非捱几十年俸，非递几十年手本，非唱几十年喏，非磕几十年头，非请几十年安，则必不能得一官、进一职。其内任卿贰以上，外任监司以上者，百人之中，其五官不备者，殆九十六七人也。非眼盲则耳聋，非手颤则足跛，否则半身不遂也。彼其一身饮食步履视听言语，尚且不能自了，须三四人左右扶之捉之，乃能度日，于此而乃欲责之以国事，是何异立无数木偶而使治天下也！且彼辈者，自其少壮之时既已不知亚细亚、欧罗巴为何处地方，汉祖唐宗是那朝皇帝，犹嫌其顽钝腐败之未臻其极，又必搓磨之，陶冶之，待其脑髓已涸，血管已塞，气息奄奄，与鬼为邻之时，然后将我二万里山河，四万万人命，一举而界于其手。呜呼！老大帝国，诚哉其老大也！而彼辈者，积其数十年之八股、白折、当差、捱俸、手本、唱喏、磕头、请安，千辛万苦，千苦万辛，乃始得此红顶花翎之服色，中堂大人之名号，乃出其全副精神，竭其毕生力量，以保持之。如彼乞儿拾金一锭，虽轰雷盘旋其顶上，而两手犹紧抱其荷包，他事非所顾也，非所知也，非所闻也。于此而告之以亡国也，瓜分也，彼乌从而听之，乌从而信之！即使果亡矣，果分矣，而吾今年七十矣，八十矣，但求其一两年内，洋人不来，强盗不起，我已快活过了一世矣！若不得已，则割三头两省之土地奉申贺敬，以换我几个衙门；卖三几百万之人民作仆为奴，以赎我一条老命，有何不可？有何难办？呜呼！今之所谓老后、老臣、老将、老吏者，其修身齐家治国平天下之手段，皆具于是矣。西风一夜催人老，凋尽朱颜白尽头。使走无常当医生，携催命符以祝寿，嗟乎痛哉！以此为国，是安得不老且死，且吾恐其未及岁而殇也。 任公曰：造成今日之老大中国者，则中国老朽之冤业也。制出将来之少年中国者，则中国少年之责任也。彼老朽者何足道，彼与此世界作别之日不远矣，而我少年乃新来而与世界为缘。如僦屋者然，彼明日将迁居他方，而我今日始入此室处。将迁居者，不爱护其窗栊，不洁治其庭庑，俗人恒情，亦何足怪！若我少年者，前程浩浩，后顾茫茫。中国而为牛为马为奴为隶，则烹脔鞭棰之惨酷，惟我少年当之。中国如称霸宇内，主盟地球，则指挥顾盼之尊荣，惟我少年享之。于彼气息奄奄与鬼为邻者何与焉？彼而漠然置之，犹可言也。我而漠然置之，不可言也。使举国之少年而果为少年也，则吾中国为未来之国，其进步未可量也。使举国之少年而亦为老大也，则吾中国为过去之国，其澌亡可翘足而待也。故今日之责任，不在他人，而全在我少年。少年智则国智，少年富则国富；少年强则国强，少年独立则国独立；少年自由则国自由；少年进步则国进步；少年胜于欧洲，则国胜于欧洲；少年雄于地球，则国雄于地球。红日初升，其道大光。河出伏流，一泻汪洋。潜龙腾渊，鳞爪飞扬。乳虎啸谷，百兽震惶。鹰隼试翼，风尘翕张。奇花初胎，矞矞皇皇。干将发硎，有作其芒。天戴其苍，地履其黄。纵有千古，横有八荒。前途似海，来日方长。美哉我少年中国，与天不老！壮哉我中国少年，与国无疆！ “三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切。”此岳武穆《满江红》词句也，作者自六岁时即口受记忆，至今喜诵之不衰。自今以往，弃“哀时客”之名，更自名曰“少年中国之少年”。","link":"/chineseTeen/"},{"title":"JVM内存区域","text":"以前一直记不住Java的内存区域有哪些，每个的作用有有哪些。之前面试也被问的一脸懵B了，所以想了想，还是把这个来看一下，熟悉一下JVM 概述 JVM内存管理包括：Method Area（方法区）、VM Stack（虚拟机栈）、Native Method Stack（虚拟机栈）、Heap（堆）、Program Counter Register(程序计数器) 图 Heap Java堆是Java虚拟机管理内存的最大一块，它是被所有线程共享的一块内存区域，在虚拟机启动时创建。 用途：存放对象实例，几乎所有的对象实例都在这里分配内存。 它是垃圾收集器管理的主要区域，因此有时候被称为GC堆。现在的垃圾收集器基本采用分代收集，所以Java堆可被细分为：新生代、老年代。再细致的话有：Eden空间、From Survivor空间、To Survivor空间。 Java堆在物理上可以处于不连续的内存空间，只要逻辑上 连续即可 通过 -Xmx、-Xms来控制最小值和最大值 当堆没有内存完成实例分配时，会抛出OutOfMemoryError 关键词：线程共享、垃圾回收 VM stack 虚拟机栈是线程私有的，它的生命周期与线程是一样的。 它描述的是Java方法执行时的内存模型；在方法执行时，会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接和方法出口等信息。方法执行的过程就是一个栈帧在虚拟机栈入栈出栈的过程。 用途：主要存储编译期可知的基本类型、对象引用。 局部变量表所需的内存是在编译期就已经完成分配的 当栈的深度超过了虚拟机允许的深度会StackOverflowError，当然虚拟机栈也可以动态扩展，但是当扩展时无法申请到足够内存时，会OutOfMemoryError 关键词： 线程私有、栈帧 Method Area 方法区与Java堆一样，是线程共享的。 用途：存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。 有人称方法区是永久代，但是本质上两者不等价，只是HotSpot团队使用永久代来实现方法区而已。 垃圾收集在这个区GC很少，回收的目标主要是对常量池的回收和对类型的下载。 可以通过-XX：MaxPermSize来调整大小上限 当方法区无法满足内存分配需求时，会报OutOfMemoryError Runtime Constant Pool 运行时常量池是方法区的一部分，Class文件中除了类的版本、字段、方法、接口等，还有一项叫常量池用于存储编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池 当常量池无法再申请到内存时，就会抛出OutOfMemoryError 关键词：线程共享、运行时常量池 Program Counter Register 它占用较小的内存空间 可以看做当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器，所以他是线程私有的 一个处理器（多核处理器来说是一个核）只会执行一个线程，为了让线程切换后恢复到正确位置，每个线程需要有一个程序技术器，各个线程之间互不影响 如果执行的java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的Native方法，计数器值为空 关键词: 线程私有、线程切换 Native Method Stack 与 VM Stack差不多, 只不过Method Stack执行Java方法， 它执行Native方法。 有时候可以将二者合称为虚拟机栈 线程私有 与VM Stack一样会抛出StackOverflowError、OutOfMemoryError 关键词: 线程私有、本地方法","link":"/jvmspace/"},{"title":"Object解析","text":"所有类的超类都是Object，但是这种继承不是Java的显示继承方式extends,猜想应该是c++中的。这个暂且不说，先来认识一下Object中的方法。 registerNatives 在初始话Object类的时候，就会调用这个方法，应该是注册这个类。 Object构造器 会给一个空构造函数，这个是从java 1.0就已经有了。 getClass 获取运行时当前对象的类对象 hashCode 计算对象的hash值，一般会被重写。是equals的伴侣，正常应用在两个对象的比较 equals 判断当前对象是否与指定对象是否相等， 默认是比较是否是同一个引用， 一般满足不了我们的需求， 所以正常会重写它。 clone 克隆当前对象，返回当前对象的克隆对象。但是只有继承了Cloneable接口的类才能使用该方法，否则会报CloneNotSupportException异常。注意：如果说对象的属性是其他对象的引用， 那么需要深度克隆。 toString 将当前对象转成String， 默认返回 类名+地址值。这场会被我们重写，因为默认的方法正常没有用。 notify 在锁争夺中唤醒一个等待该对象持有锁的其他对象， 让其对象进行锁争夺。注意当前线程必须是对象持有锁的线程，否则会报IllegalMonitorStateException。与之相同的还有notifyAll,它是唤醒所有等待中的对象。 notifyAll 在锁争夺中唤醒等待该对象持有锁的其他对象， 让对象进行锁争夺。注意当前线程必须是对象持有锁，否则会报IllegalMonitorStateException。与之相同的还有notify,它是唤醒所有等待中的对象。 wait 当前线程等待，进入线程池等待，并且释放锁资源,等待notify唤醒。其实质调用的是它的重载方法 wait(long timeoutMillis)， 参数是 0L finalize 通知垃圾回收， 回收这个对象。但是什么时候回收是有GC自己控制的， 这个方法只是标识这个对象需要被回收了","link":"/object/"},{"title":"SpringCloudAlibaba","text":"SpringCloudAlibaba现在感觉越来越多人知道了， 之前去参加了一次在深圳举办面基大会,了解了一下当前的现状。 Netflix 不好的消息在于，Spring Cloud Netflix Oss的组件已经差不多全军覆没了，好像除了Eureka之外，其他已经进入维护期了， 用阿里大佬的话来说就是， 已经进入维护期，就意味着即将淘汰。 不过想想，在一个技术高速发展的今天，Netflix OSS进入维护，也就相当于，它放弃了。 所以我就信了阿里大佬的话，决定看看SpringCloudAlibaba。 SpringCloudAlibaba 既然Netflix进入了维护期， 那么Alibaba理所当然的粉墨登场了。 提到了Ali，联想到的自然就是Dubbo，SpringCloudAlibaba就是阿里系的dubbo、sentinel、nacos集成进去了。从这些来看nacos阶梯了eureka和archaius来做分布式配置和服务的注册发现，而 sentinel则替代了hystrix成了服务容错的新选择，当然最大头的还是Dubbo，它完全的替代了Feign、zuul。所以感觉玩好SpringCloudAlibaba还是得玩好Dubbo。 结尾 以上就是我的一些废话，感觉毫无实际意义，但是这个是我第一篇真正意义上的博客，所以还是留着呢。最后贴上一幅SpringCloudNetlfix的替换方案。这张图是 SpringCloudAlibaba PMC 方剑 在2019年7月在深圳的宣讲中它的PTT中的，引用还是得说明其出处的。","link":"/springalibaba/"},{"title":"初识SpringCloudStream","text":"最近公司的一个新项目使用到了SpringCloudStream,自己也对它早有耳闻，所以接着这次的机会，了解学习一下它。 简介 SpringCloudStream是一个用来为微服务应用构建消息驱动能力的架构，可以基于Spring Boot来创建独立的可用于生产的Spring应用程序。其实质依旧是Spring Integration，它利用Spring Integration来连接消息代理中间件。目前支持消息中间件有RabbitMQ，Kafka。 SpringCloudStream处理架构 Sample配置文件12345678server: port: 8080spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest 代码示例123456//消费者@StreamListener(SINK.INPUT)public void receiver(Object payload) { String profile = System.getProperty(\"profile\"); System.out.println(\"Received : \" + profile + \"-&gt;\"+ payload); } 123456@Autowireprivate Source source;//生产者public void sendMsg(){ source.output().send(MessageBuilder.withPayload(\"Test Demo\").build());} 1234567@SpringBootApplication@EnableBinding({ Sink.class,Source.class})public class StreamApplication { public static void main(String[] args) { SpringApplication.run(StreamApplication.class, args); }} 以rabbitMQ举例，运行时会创建两个Exchange(input、output)及其input相应的Queue（input.anonymous.3_HBKc9TTFSML-9UtlHz_g），而等到发送消息时会新建一个Connection用于发送。 基本概念Binder 绑定器 Binder的作用在于隔离各种消息中间件的细节，统一暴露Channel通道。 123456spring: cloud: stream: bindings: input: destination: aa 消费组 当同一个消息有多个消费者，且只想被一个消费者消费时，使用消费组就可以解决这个问题 123456spring: cloud: stream: bindings: input: group: demo-A 某些场景下，我们需要在同一个实例上使用同一个channel进行消息的收发，那么我们会发现output和input的通道名一致时会报bean已存在的错， 我们可以通过destination来配置 12345678spring: cloud: stream: bindings: input: destination: des-A output: destination: des-A 消息分区 有时候我们想将一类的消息，都只交给某个消费者消费，那么就需要进行消息的分区处理了 12345678910111213141516171819202122# consumercloud: stream: bindings: intput: # 开启消费者分区功能 partitioned: trueh # 总实例数 instanceCount: 2 # 当前实例索引号 instanceIndex: 0#producercloud: stream: bindings: out-put: producer: # SPEL 分区键的表达式规则 partitionKeyExpression: payload # 分区数量 partitionCount: 2 消息类型 SpringCloudStream默认实现了多个消息转换的方式，我们可以使用spring.cloud.stream.bindings.&lt;channelName&gt;.conten-type来声明配置消息内容的类型 123456spring: cloud: stream: bindings: input: contentType: application/json 多绑定器的配置 一些场景下，可能一个实例存在多个绑定器，而SpringCloudStream在为消息通道绑定是，无法判断使用哪个绑定器，这时候需要我们指定绑定器。而在使用时往往会有一个绑定器为主要使用，另一个用得少，我们可以通过绑定默认绑定器来指定多数通道的绑定器，之后再为其他通道设置绑定器 1234567spring: cloud: stream: defaultBinder: rabbit bindings: input: binder: kafka 当然我们也可使用同个类型不同环境的绑定器 123456789101112131415161718192021222324252627spring: cloud: stream: bindings: input: binder: rabbit1 output: binder: rabbit2 binders: rabbit1: type: rabbit environment: spring: rabbitmq: hout: 127.0.0.1 port: 5672 username: guest password: guest rabbit2: type: rabbit environment: spring: rabbitmq: hout: 127.0.0.1 port: 5673 username: guest password: guest Last 以上便是SpringCloudStream的一些使用，但是是跟RabbitMQ结合，事实上，与Kafka结合的话还是有些不同。","link":"/springCloudStream1/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"AMQP","slug":"AMQP","link":"/tags/AMQP/"},{"name":"诗","slug":"诗","link":"/tags/诗/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Cloud","slug":"Cloud","link":"/tags/Cloud/"},{"name":"Alibaba","slug":"Alibaba","link":"/tags/Alibaba/"},{"name":"SpringCloudStream rabbit","slug":"SpringCloudStream-rabbit","link":"/tags/SpringCloudStream-rabbit/"}],"categories":[{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"MQ","slug":"MQ","link":"/categories/MQ/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"}]}